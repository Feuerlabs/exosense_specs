// ---- BEGIN COPYRIGHT ---------------------------------------------
//
// Copyright Â© 2012 Feuerlabs, Inc. All rights reserved.
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License, v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// ---- END COPYRIGHT -----------------------------------------------
module exodm {
    namespace "http://feuerlabs.com/exodm";
    prefix exodm;

    import ietf-inet-types {
      prefix inet;
    }
    import exosense {
      prefix exo;
    }

    description "Data model for Exosense Device Management Server";

    contact "ulf.wiger@feuerlabs.com";
    organization "Feuerlabs, Inc.";

    revision 2012-11-30 {
      description
	"Added device-type definitions; harmonized ID string lengths, " +
	"some cleanups to stay within 80 char line lengths.";
    }
    revision 2012-10-26 {
      description "Validation and cleanup";
    }


    // Result codes used by all requests/replies.
    // Can be augmented by local code in special cases.
    typedef result-code {
        type enumeration {
            enum ok {
	      description "Operation has completed successfully.";
	      value 0;
            }
            enum permission-denied {
	      description "Insufficient privileges to perform operation.";
	      value 1;
            }
            enum validation-failed {
	      description "An error occurred validating the YANG module.";
	      value 2;
            }
            enum object-exists {
	      description "An object with the same identifier already exists.";
	      value 3;
            }
            enum object-not-found {
	      description "No object with the given identifier has been found.";
	      value 4;
            }
            enum device-not-found {
	      description "No device with the given identifier has been found.";
	      value 5;
            }
	    enum object-not-empty {
	      description "Members must be removed before deleting.";
	      value 6;
	    }
        }
    }

    typedef id-string {
      description "Common type for string identifiers in exodm";
      type string {
	length "1..64";
      }
    }

    // INTERNAL INFO!
    // <uid>/groups/<gid>/name
    // <uid>/groups/<gid>/url
    //
    list groups {
	description "Device group information";

	key "gid";

	leaf gid {
	  description "group id";
	  type uint32;
	}

	leaf name {
	    type string;
	}

	leaf notification-url {
	    description "Where to send notifications";
	    type inet:uri;
	}
    }

    grouping device-type-obj {
      description "Device type object leafs";
      leaf name {
	description "Account-wide unique device type name";
	mandatory true;
	type id-string;
      }
      leaf protocol {
	description "Protocol between device and Exosense server";
	mandatory true;
	type id-string;
      }
    }

    grouping device-obj {
      description "Device object leafs";

      leaf dev-id {
	description "Account-wide unique device-id";
	type id-string;
	mandatory true;
      }
      leaf device-type {
	description "Type of device";
	type id-string;
	mandatory true;
      }
      leaf description {
	description "User-provided description of device";
	type string;
      }
      leaf server-key {
	description "Server key";
	type uint64;
      }
      leaf device-key {
	description "Device key";
	type uint64;
      }
      leaf msisdn {
	type string;
      }
      leaf imsi {
	type string;
      }
      leaf imei {
	type string;
      }
      leaf latitude {
	description "Latitude of device location";
	type decimal64 {
	  fraction-digits 6;
	}
      }
      leaf longitude {
	description "Longitude of device location";
	type decimal64 {
	  fraction-digits 6;
	}
      }
    }

    // INTERNAL INFO!
    // <uid>/devices/<did>/name    = string()
    // <uid>/devices/<did>/msisdn  = msisdn()
    // <uid>/devices/<did>/imsi    = imsi()
    // <uid>/devices/<did>/imei    = imei()
    // <uid>/devices/<did>/__ck    = uint64()
    // <uid>/devices/<did>/__sk    = uint64()
    // <uid>/devices/<did>/groups[1]/__gid = uint32()
    //
    list devices {
	description "Device information";
	key "did";

	leaf did {
	    description "Device identifer";
	    // internally it must be escaped!
	    type id-string;
	}

	leaf name {
	    description "Optional device name";
	    type string;
	}

	list groups {
	    description "Device group member ship";
	    key "id";

	    leaf id {
                description "access index";
                type uint32;
	    }

	    leaf __gid {
		description "group id";
		type uint32;
	    }
	}

	leaf msisdn {
	    description "phone number used to access device if any";
	    type string;
	}

	leaf imsi {
	    description "simcard identity, used to sign some data";
	    type string;
	}

	leaf imei {
	    description "modem identity number";
	    type string;
	}

	leaf __ck {
	    description "device key";
	    type uint64;
	}

	leaf __sk {
	    description "server key";
	    type uint64;
	}

    }

    // INTERNAL INFO!
    // user/<uname>/fullname      = string()
    // user/<uname>/phone         = string()
    // user/<uname>/email         = string()
    // user/<uname>/skype         = string()
    // user/<uname>/access[<i>].__uid  = uint32()
    // user/<uname>/access[<i>].__gid  = uint32()
    // user/<uname>/access[<i>].__perm = permission()
    //
    list users {
	description "User information";
	key "name";


	leaf name {
	    description "Login name of user, unique";
	    type id-string;
	}

	leaf fullname {
	    type string;
	}

	leaf phone {
	    type string;
	}

	leaf email {
	    type string;
	}

	leaf skype {
	    type string;
	}

	leaf __password {
	    type string;
	}

	list access {
	    description "Device group access";
	    key "id";

	    leaf id {
                description "access index";
                type uint32;
	    }

	    leaf __uid {
                description "Device owner id";
                type uint32;
	    }

	    leaf __gid {
                description "group name";
                type uint32;
	    }

	    leaf __perm {
                description "group permissions, r,w or rw";
                type string;
	    }
	}
    }

    rpc create-device-group {
        description "RPC to create a device group";

        input {
            leaf name {
                description "Group name";
                type id-string;
            }
            leaf notification-url {
                description "RPC callback notification URL";
                type inet:uri;
            }
        }

        output {
            leaf result {
                type result-code;
            }
            leaf gid {
                description "Group identifier. 0 (zero) if operation failed.";
                type uint32;
            }
        }
    }

    rpc delete-device-group {
        description "RPC to create a device group";

        input {
            leaf gid {
                description "Group ID";
                type uint32;
            }
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc create-device-type {
        description "RPC to create a device type";

        input {
	  uses device-type-obj;
	}

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc update-device-type {
      description "RPC to modify an existing device type.";
      input {
	uses device-type-obj {
	  refine protocol {
	    mandatory false;
	  }
	}
      }
      output {
	leaf result {
	  type result-code;
	}
      }
    }

    rpc delete-device-type {
        description "RPC to create a device type";

        input {
            leaf name {
                description "Device type name";
                type id-string;
            }
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc list-device-types {
      description "RPC to list device types.";
      input {
	leaf n {
	  description "Number of entries to fetch";
	  type uint32;
	}
	leaf previous {
	  description 'Previous device type; "" if from beginning';
	  type id-string;
	}
      }
      output {
	list device-types {
	  uses device-type-obj;
	}
      }
    }

    rpc list-device-type-members {
      description "List device IDs associated with a device type";
      input {
	leaf name {
	  description "Name of device type";
	  type id-string;
	}
	leaf n {
	  description "Number of entries to fetch";
	  type uint32;
	}
	leaf previous {
	  description 'Previous device ID; "" if from beginning';
	  type id-string;
	}
      }
      output {
	leaf-list device-type-members {
	  description "Device ID";
	  type id-string;
	}
      }
    }

    rpc list-devices {
        description "List provisioned devices, N entries at a time";

        input {
            leaf n {
                description "Number of entries to fetch";
                type uint32;
            }
            leaf previous {
	      description "Previous device ID; \"\" if from beginning";
                type id-string;
            }
        }
        output {
            list devices {
	      uses device-obj;
            }
        }
    }


    rpc list-config-sets {
        description "List config sets, N entries at a time";

        input {
            leaf n {
                description "Number of entries to fetch";
                type uint32;
            }
            leaf previous {
	      description "Previous config set; \"\" if from beginning";
                type id-string;
            }
        }
        output {
            list config-sets {
                leaf name {
		  type id-string;
                }
                leaf yang {
                    type string;
                }
                leaf notification-url {
                    type inet:uri;
                }
            }
        }
    }

    rpc list-config-set-members {
        description "List members of a config set, N entries at a time";

        input {
	  leaf name {
	    description "Name of the config set";
	    type id-string;
	  }
	  leaf n {
	    description "Number of entries to fetch";
	    type uint32;
	  }
	  leaf previous {
	    description "Previous member; \"\" if from beginning";
	    type id-string;
	  }
        }
        output {
	  leaf-list config-set-members {
	    description "";
	    type id-string;
	  }
	}
    }

    rpc list-device-groups {
      description "List device groups, N entries at a time";

      input {
	leaf n {
	  description "Number of entries to fetch";
	  type uint32;
	}
	leaf previous {
	  description
	    "Previous device group id (GID); \"\" if from beginning";
	  type uint32;
	}
      }
      output {
	list device-groups {
	  leaf gid {
	    type uint32;
	  }
	  leaf name {
	    type id-string;
	  }
	  leaf notification-url {
	    type inet:uri;
	  }
	}
      }
    }


    rpc list-device-group-members {
        description "List devices attached to a device group, " +
	  "N entries at a time";

        input {
	  leaf gid {
	    description "ID of the device group";
	    type uint32;
	  }
	  leaf n {
	    description "Number of entries to fetch";
	    type uint32;
	  }
	  leaf previous {
	    description "Previous device; \"\" if from beginning";
	    type id-string;
	  }
        }
        output {
	  leaf-list device-group-members {
	    description "";
	    type id-string;
	  }
	}
    }


    rpc add-device-group-members {
        description "Link devices to device groups";
        input {
            leaf-list device-groups {
                description
		  "Device groups to associate with the given device(s)";
                type uint32;
            }
            leaf-list dev-id {
                description "List of Device ID(s)";
                type id-string;
            }
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc remove-device-group-members {
      description "Unlink devices from device groups";
      input {
	leaf-list device-groups {
	  description
	    "Device groups to unlink the given device(s) from";
	  min-elements 1;
	  type uint32;
	}
	leaf-list dev-id {
	  description "List of device ID(s)";
	  min-elements 1;
	  type id-string;
	  }
	}
      output {
	leaf result {
	  type result-code;
	}
      }
    }


    rpc update-device-group {
        description "RPC to change the notification URL of an existing group";

        input {
            leaf gid {
                description "Group identifier.";
                type uint32;
            }
            leaf notification-url {
                description "RPC callback notification URL";
                type inet:uri;
            }
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc create-yang-module {
        description "RPC to store a YANG module either in user or system space";
        input {
            leaf repository {
                description
		  "Where to store the module: Currently \"system\" or \"user\"";
                type id-string;
            }
            leaf name {
                description "Name, including extension, e.g. 'rfzone.yang'";
                type id-string;
            }
            leaf yang-module {
                description "The actual source of the YANG module specification";
                type id-string;
            }
        }
        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc list-yang-modules {
      description "RPC to list existing yang modules.";
      input {
	leaf repository {
	  description "\"system\" or \"user\"; default: \"user\"";
	  type id-string;
	  default "user";
	}
	leaf n {
	  description "Number of entries to fetch.";
	  type uint32;
	}
	leaf previous {
	  description "Previous yang filename.";
	  type id-string;
	}
      }
      output {
	leaf-list yang-modules {
	  type string;
	}
      }
    }

    rpc create-config-set {
        description "RPC to create device config data set";
        input {
            leaf name {
                description "Name of the config data set";
                type id-string;
            }
            leaf yang {
                description "Name of the corresponding yang file - must exist.";
                type id-string;
            }
	    leaf notification-url {
	         description "Notification URL";
		 type inet:uri;
            }
            anyxml values {
                description "Configuration values (validated against the yang spec)";
            }
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc update-config-set {
        description "RPC to update existing config data set";
        input {
            leaf name {
                description "Name of the config data set";
                type id-string;
            }
	    leaf notification-url {
	        description "Notification URL";
		type inet:uri;
	    }
            anyxml values {
                description
		  "Configuration values (validated against the yang spec)";
            }
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc delete-config-set {
        description
	  "RPC to delete a config data set. " +
	  "Any member devices must first be removed.";
        input {
            leaf name {
                description "Name of the config data set";
                type id-string;
            }
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc provision-device {
        description
	  "Create a new device. " +
	  "augment this call if you want to add device-data";
        input {
	  uses device-obj;
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc update-device {
      description "RPC to update an existing device object.";
      input {
	uses device-obj {
	  refine device-type {
	    mandatory false;
	  }
	}
      }
      output {
	leaf result {
	  type result-code;
	}
      }
    }

    rpc lookup-device {
      description
	"RPC to read a single device object." +
	"Returns a list of zero or one device object.";
      input {
	leaf dev-id {
	  type id-string;
	}
      }
      output {
	leaf result {
	  type result-code;
	}
	list devices {
	  uses device-obj;
	}
      }
    }

    rpc deprovision-devices {
      description "RPC to deprovision a set of existing devices.";

      input {
	leaf-list dev-id {
	  description "Account-wide unique device-id";
	  type id-string;
	}
      }

      output {
	leaf result {
	  type result-code;
	}
      }
    }


    rpc add-config-set-members {
        description
	  "Create a new device. augment this call if you want to add " +
	  "device-data";
        input {
            leaf-list name {
                description
		  "Configuration data instances to associate with " +
		  "the given device(s)";
                type id-string;
            }
            leaf-list dev-id {
                description
		  "Devices to push the given config data instances to (s)";
                type id-string;
            }
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    rpc remove-config-set-members {
        description
	  "Remove a config set member.";
        input {
            leaf-list name {
                description
		  "Configuration data instances from which to remove " +
		  "the given devices";
		min-elements 1;
                type id-string;
            }
            leaf-list dev-id {
                description
		  "Devices to remove from the given config data instances";
		min-elements 1;
                type id-string;
            }
        }
        output {
            leaf result {
                type result-code;
            }
        }
    }


    rpc push-config-set {
        description "Push the given configuration data to all member devices";
	exo:matching-notification "push-config-set-callback";
        input {
            leaf name {
                description "Name of configuration data set to push.";
                type id-string;
            }
        }

        output {
            leaf result {
                type result-code;
            }
        }
    }

    notification push-config-set-callback {
      uses exo:std-callback;
    }


    //
    // Package management
    //
     rpc create-package {
         description
	   "Create a package in the database to be forwarded to devices.";
         input {
             leaf package-name {
                 description "Name of package.";
                 type string {
                     length "1..256";
                 }
             }
             list dependencies {
                 key package-name;

                 leaf package-name {
                     type string {
                         length "1..256";
                     }
                 }
             }

             anyxml image {
                 description "The package image itself.";
             }
         }

         output {
             leaf result {
                 type result-code;
             }
         }
     }

     notification create-package-notification {
       uses exo:std-callback;
     }

     rpc add-package-members {
         description
 	  "Add members to the list of devices to receive the package.";
         input {
             leaf-list package-name {
                 description
 		  "Configuration data instances to associate with " +
 		  "the given device(s)";
                 type string {
                     length "1..256";
                 }
             }
             leaf-list dev-id {
                 description
 		  "Devices to push the given config data instances to (s)";
                 type id-string;
             }
         }

         output {
             leaf result {
                 type result-code;
             }
         }
     }


     // MAYBE WE SHOULD BREAK UP TRANSMIT AND OPERATION INTO TWO
     // DIFFERENT CALLS?
     rpc push-package {
         description
	   "Pushes the given package to all member devices. Notifications " +
	   "will be sent back. If the package is already pushed to a device, " +
	   "it will not be transmitted again. Instead the specified " +
	   "operation will be executed for the package on the given device.";

         input {
             leaf package-name {
                 type string {
                     length "1..64";
                 }
             }

             leaf operation {
	       description
		 "The operation to be carried out on the package once it " +
		 "has been received on a device.";

	       type enumeration {
		 enum transmit {
		   description
		     "Do not do any operations apart from transmitting the " +
		     "package. This is a no-op if the package is already " +
		     "resident on the target device.";
		   value 0;
		 }

		 enum install {
		   description
		     "Install the package using the device-local package " +
		     "manager.";
		   value 1;
		 }

		 enum upgrade {
		   description
		     "Upgrade the package using the device-local package " +
		     "manager.";
		   value 2;
		 }

		 enum uninstall {
		   description
		     "Uninstall the package using the device-local package " +
		     "manager.";
		   value 3;
		 }

		 enum remove {
		   description
		     "Remove the package from the device. If the package is " +
		     "not present on the device, an error will be sent back " +
		     "through the push-package-notification.";
		   value 4;
		 }

		 enum remove-recursively {
		   description
		     "Remove the package from and recursively remove any " +
		     "dependent packages that are no longer resolving any " +
		     "device-local dependencies. If the package is not " +
		     "present on the device, an error will be sent " +
		     "back through the push-package-notification.";
		   value 5;
		 }
	       }
             }

             leaf timeout {
	       description
		 "Timeout specification for this operation to be carried out " +
		 "to a device. If a timeout occur, an error is sent back for "+
		 "the timed out device using push-package-notification. " +
		 "Please note that some devices may time out while others " +
		 "succeed.";

	       type string {
		 length "1..64";
	       }
             }

             leaf auto-push-dependencies {
	       description
		 "Specifies if any unresolved dependencies should " +
		 "automatically be pushed to the target as well. If set to " +
		 "false, each device with an unresolved dependency will " +
		 "generate an error push-package-notification";

	       type boolean;
             }

             leaf remove-after-operation {
	       description
		 "Specifies if the package should be removed from " +
		 "device-local storage once the operation (such as install) " +
		 "has been carried out on the device. If the auto-push-" +
		 "dependencies flag is set, any packages automatically " +
		 "transmitted to resolve dependencies will be removed as well.";

	       type boolean;
             }

             leaf replace-queue {
	       description
		 "If set to true, any earlier operations for this package " +
		 "queued to the given device will be removed and replaced " +
		 "by the operation specified by this command. If set to " +
		 "false, this command will be queued to be executed after " +
		 "any other pending commands for this package to the given " +
		 "device.";

	       type boolean;
             }
         }
         output {
	   leaf result {
	     type result-code;
	   }
         }
     }

     notification push-package-notification {
       uses exo:std-callback;
     }

//     rpc list-packages {
//         description "List all packages in the system";

//         output {
//             leaf result {
//                 type result-code;
//             }

//             leaf-list package-list {
//                 description "Name of package";

//                 type string {
//                     length "1..256";
//                 }
//             }
//         }
//     }

//     rpc get-package-status {
//         description "Retrieve status for a specific package";

//         input {
//             leaf package-name {
//                 type string {
//                     length "1..256";
//                 }
//             }
//         }

//         output {
//             leaf result {
//                 type result-code;
//             }

//             list member-list {
//                 description
//                     "List of all members receiving the package, and their status.";

//                 key dev-id;

//                 leaf dev-id {
//                     description "The device id of the member.";
//                     type string {
//                         length "1..64";
//                     }
//                 }


//                 // The last operation carried out for the package on this device
//                 leaf operation {
//                     description
//                         "Last operation carried out for the package on this device";

//                     type enumeration {
//                         enum pending {
//                             description
//                                 "The package has been uploaded to the server but not pushed.";
//                         }

//                         enum transmit {
//                             description
//                                 "The package is to be transmitted to to the device, but no" +
//                                 "operations are to be carried out once it arrives.";

//                         }

//                         enum install {
//                             description
//                                 "The package is to be transmitted and installed on the device.";
//                         }

//                         enum upgrade {
//                             description
//                                 "The package is to be transmitted and upgraded on the device.";
//                         }

//                         enum uninstalled {
//                             description
//                                 "The package is to be uninstalled from the device.";
//                         }

//                         enum remove {
//                             description
//                                 "The package is to be removed.";
//                         }
//                     }
//                 }

//                 // The status of the last operation carried out
//                 leaf operation-status {
//                     description "Status of the operation.";
//                     type enumeration {
//                         enum completed;
//                         enum queued;
//                         enum timeout;
//                         enum dependency-failure;
//                         enum other-error;
//                     }
//                 }
//             }
//         }
//     }
}

